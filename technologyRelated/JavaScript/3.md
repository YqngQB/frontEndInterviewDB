# 前端面试 - JavaScript【手写相关】

[TOC]

## 1. 手写防抖函数

```js
/**
 * 函数防抖 (只执行最后一次点击)
 */
Debounce = (fn, t) => {
    let delay = t || 500;
    let timer;
    return function () {
        let args = arguments;
        if (timer) {
            clearTimeout(timer);
        }
        timer = setTimeout(() => {
            timer = null;
            fn.apply(this, args);
        }, delay);
    }
};

```

## 2. 手写节流函数

```js
/**
 * 函数节流（一段时间内只执行一次）
 */
Throttle = (fn, t) => {
    let last;
    let timer;
    let interval = t || 500;
    return function () {
        let args = arguments;
        let now = +new Date();
        if (last && now - last < interval) {
            clearTimeout(timer);
            timer = setTimeout(() => {
                last = now;
                fn.apply(this, args);
            }, interval);
        } else {
            last = now;
            fn.apply(this, args);
        }
    }
};


```

## 3. 手写深度克隆

```js
/**
 * 乞丐版，最简单的实现方式能满足一般的工作场景
 *
 * 如果 对象中存在循环引用的情况无法正确实现深拷贝。
 * 如果 data 里面有时间对象，则JSON.stringify后再JSON.parse的结果，时间将只是字符串的形式。而不是时间对象。
 * 如果 data 里有NaN、Infinity和-Infinity，则序列化的结果会变成null
 * 如果 data 里有RegExp、Error对象，则序列化的结果将只得到空对象；
 *  */
JSON.parse(JSON.stringify(data))

/***
 * 面试凑合用版
 */
function deepClone(obj) {
    //判断是否是简单数据类型，
    if (typeof obj == "object") {
        //复杂数据类型
        var result = obj.constructor == Array ? [] : {};
        for (let i in obj) {
            result[i] = typeof obj[i] == "object" ? deepCopy(obj[i]) : obj[i];
        }
    } else {
        //简单数据类型 直接 == 赋值
        var result = obj;
    }
    return result;
}


/**
 * 进阶版，已经满足平时大部分开发的需求
 * 只考虑了 Array、Object 两种引用类型数据的处理，引用类型的数据还有Function 函数、Date 日期、RegExp 正则、Map 数据结构、Set 数据机构，其中 Map 、Set 属于 ES6 的。
 *  */
function deepClone(target) {
    /**
     * 遍历数据处理函数
     * @array 要处理的数据
     * @callback 回调函数，接收两个参数 value 每一项的值 index 每一项的下标或者key。
     */
    function handleWhile(array, callback) {
        const length = array.length;
        let index = -1;
        while (++index < length) {
            callback(array[index], index)
        }
    }

    function clone(target, map) {
        if (target !== null && typeof target === 'object') {
            let result = Object.prototype.toString.call(target) === "[object Array]" ? [] : {};
            // 解决循环引用
            if (map.has(target)) {
                return map.get(target);
            }
            map.set(target, result);

            const keys = Object.prototype.toString.call(target) === "[object Array]" ? undefined : Object.keys(
                target);

            function callback(value, key) {
                if (keys) {
                    // 如果keys存在则说明value是一个对象的key，不存在则说明key就是数组的下标。
                    key = value;
                }
                result[key] = clone(target[key], map)
            }

            handleWhile(keys || target, callback)
            return result;
        } else {
            return target;
        }
    }

    let map = new WeakMap();
    const result = clone(target, map);
    map = null;
    return result
}


/**
 * 最终完整版【包括 Set、Map、Function的处理】
 * */
function deepClone(target) {
    // 获取数据类型
    function getType(target) {
        return Object.prototype.toString.call(target)
    }

    //判断数据是不是引用类型
    function isObject(target) {
        return target !== null && (typeof target === 'object' || typeof target === 'function');
    }

    //处理不需要遍历的应引用类型数据
    function handleOherData(target) {
        const type = getType(target);
        switch (type) {
            case "[object Date]":
                return new Date(target)
            case "[object RegExp]":
                return cloneReg(target)
            case "[object Function]":
                return cloneFunction(target)

        }
    }

    //拷贝Symbol类型数据
    function cloneSymbol(targe) {
        const a = String(targe); //把Symbol字符串化
        const b = a.substring(7, a.length - 1); //取出Symbol()的参数
        return Symbol(b); //用原先的Symbol()的参数创建一个新的Symbol
    }

    //拷贝正则类型数据
    function cloneReg(target) {
        const reFlags = /\w*$/;
        const result = new target.constructor(target.source, reFlags.exec(target));
        result.lastIndex = target.lastIndex;
        return result;
    }

    //拷贝函数
    function cloneFunction(targe) {
        //匹配函数体的正则
        const bodyReg = /(?<={)(.|\n)+(?=})/m;
        //匹配函数参数的正则
        const paramReg = /(?<=\().+(?=\)\s+{)/;
        const targeString = targe.toString();
        //利用prototype来区分下箭头函数和普通函数，箭头函数是没有prototype的
        if (targe.prototype) { //普通函数
            const param = paramReg.exec(targeString);
            const body = bodyReg.exec(targeString);
            if (body) {
                if (param) {
                    const paramArr = param[0].split(',');
                    //使用 new Function 重新构造一个新的函数
                    return new Function(...paramArr, body[0]);
                } else {
                    return new Function(body[0]);
                }
            } else {
                return null;
            }
        } else { //箭头函数
            //eval和函数字符串来重新生成一个箭头函数
            return eval(targeString);
        }
    }

    /**
     * 遍历数据处理函数
     * @array 要处理的数据
     * @callback 回调函数，接收两个参数 value 每一项的值 index 每一项的下标或者key。
     */
    function handleWhile(array, callback) {
        let index = -1;
        const length = array.length;
        while (++index < length) {
            callback(array[index], index);
        }
    }

    function clone(target, map) {
        if (isObject(target)) {
            let result = null;
            if (getType(target) === "[object Array]") {
                result = []
            } else if (getType(target) === "[object Object]") {
                result = {}
            } else if (getType(target) === "[object Map]") {
                result = new Map();
            } else if (getType(target) === "[object Set]") {
                result = new Set();
            }

            // 解决循环引用
            if (map.has(target)) {
                return map.get(target);
            }
            map.set(target, result);

            if (getType(target) === "[object Map]") {
                target.forEach((value, key) => {
                    result.set(key, clone(value, map));
                });
                return result;
            } else if (getType(target) === "[object Set]") {
                target.forEach(value => {
                    result.add(clone(value, map));
                });
                return result;
            } else if (getType(target) === "[object Object]" || getType(target) === "[object Array]") {
                const keys = getType(target) === "[object Array]" ? undefined : Object.keys(target);

                function callback(value, key) {
                    if (keys) {
                        // 如果keys存在则说明value是一个对象的key，不存在则说明key就是数组的下标。
                        key = value
                    }
                    result[key] = clone(target[key], map)
                }

                handleWhile(keys || target, callback)
            } else {
                result = handleOherData(target)
            }
            return result;
        } else {
            if (getType(target) === "[object Symbol]") {
                return cloneSymbol(target)
            } else {
                return target;
            }
        }
    }

    let map = new WeakMap;
    const result = clone(target, map);
    map = null;
    return result
}

```

## 4. 手写 EventBus

```js
class EventEmitter {
    constructor() {
        this.cache = {}
    }

    on(name, fn) {
        if (this.cache[name]) {
            this.cache[name].push(fn)
        } else {
            this.cache[name] = [fn]
        }
    }

    off(name, fn) {
        let tasks = this.cache[name]
        if (tasks) {
            const index = tasks.findIndex(f => f === fn || f.callback === fn)
            if (index >= 0) {
                tasks.splice(index, 1)
            }
        }
    }

    emit(name, once = false, ...args) {
        if (this.cache[name]) {
            // 创建副本，如果回调函数内继续注册相同事件，会造成死循环
            let tasks = this.cache[name].slice()
            for (let fn of tasks) {
                fn(...args)
            }
            if (once) {
                delete this.cache[name]
            }
        }
    }
}

// 测试
let eventBus = new EventEmitter()
let fn1 = function (name, age) {
    console.log(`${name} ${age}`)
}
let fn2 = function (name, age) {
    console.log(`hello, ${name} ${age}`)
}
eventBus.on('aaa', fn1)
eventBus.on('aaa', fn2)
eventBus.emit('aaa', false, '布兰', 12)
// '布兰 12'
// 'hello, 布兰 12'

```

## 5. 手写 instanceof

```js
function instanceOf(left, right) {

    let proto = left.__proto__;
    let prototype = right.prototype
    while (true) {
        if (proto === null) return false
        if (proto === prototype) return true
        proto = proto.__proto__;
    }
}


```

## 6. 手写内置 new

```js
/***new的具体步骤
 创建一个空对象 var obj = {}
 修改obj.__proto__=Dog.prototype
 只改this指向并且把参数传递过去,call和apply都可以
 根据规范，返回 null 和 undefined 不处理，依然返回obj
 **/
function Dog(name) {
    this.name = name
}

Dog.prototype.sayName = function () {
    console.log(this.name)
}

// 上面是本身Dog
function _new(fn, ...args) {   // ...args为ES6展开符,也可以使用arguments
                               //先用Object创建一个空的对象,
    const obj = Object.create(fn.prototype)  //fn.prototype代表 用当前对象的原型去创建
    //现在obj就代表Dog了,但是参数和this指向没有修改
    const rel = fn.apply(obj, args)
    //正常规定,如何fn返回的是null或undefined(也就是不返回内容),我们返回的是obj,否则返回rel
    return rel instanceof Object ? rel : obj
}

var _newDog = _new(Dog, '这是用_new出来的小狗')
_newDog.sayName()
```

## 7. 手写 call/apply/bind
```js

//call
Function.prototype.myCall = function(context) {
    if (typeof context === "undefined" || context === null) {
        context = window
    }
   //context=context||window  和上面的代码一样
    context.fn = this
    const args = [...arguments].slice(1)
    const result = context.fn(...args)
    delete context.fn
    return result
}

// apply
Function.prototype.myApply = function(context) {
    if (typeof this !== 'function') {
        throw new TypeError('Error')
    }
    context = context || window
    context.fn = this
    let result
    if (arguments[1]) {
        result = context.fn(...arguments[1])
    } else {
        result = context.fn()
    }
    delete context.fn
    return result
}

// bind
Function.prototype.myBind = function(context) {
    if (typeof this !== 'function') {
        throw new TypeError('Error')
    }
    //返回一个绑定this的函数，这里我们需要保存this
    const _this = this
    const args = [...arguments].slice(1)
    //返回一个函数
    return function F() {
        //因为返回一个函数，我们可以new F()需要判断能当做构造函数吗
        if (this instanceof F) {
            return new _this(...args, ...arguments)
        }
        return _this.apply(context, args.concat(...arguments))
    }
}

```

## 8. 手写 Object.create
```js
function _create(obj){
    function C(){}
    C.prototype = obj;
    return new C();
}

var obj1 = {name: "Lilei"};
var lilei = _create(obj1);
lilei; // {}
lilei.name; // "Lilei"
```

## 9. 手写 JSON.parse
```js
```

## 10. 手写 Promise
```js
/**
 * 乞丐版
 * */
function Promi(executor) {
    executor(resolve, reject);
    function resolve() {}
    function reject() {}
}

function Promi(executor) {
    let _this = this;
    _this.$$status = 'pending';
    _this.failCallBack = undefined;
    _this.successCallback = undefined;
    _this.error = undefined;
    setTimeout(_ => {
        try {
            executor(_this.onResolve.bind(_this), _this.onReject.bind(_this))
        } catch (e) {
            _this.error = e;
            if (_this.callBackDefer && _this.callBackDefer.fail) {
                _this.callBackDefer.fail(e)
            } else if (_this._catch) {
                _this._catch(e)
            } else {
                throw new Error('un catch')
            }
        }
    })
}

Promi.prototype = {
    constructor: Promi,
    onResolve: function(params) {
        if (this.$$status === 'pending') {
            this.$$status = 'success';
            this.resolve(params)
        }
    },
    resolve: function(params) {
        let _this = this;
        let successCallback = _this.successCallback;
        if (successCallback) {
            _this.defer(successCallback.bind(_this, params));
        }
    },
    defer: function(callBack) {
        let _this = this;
        let result;
        let defer = _this.callBackDefer.success;
        if (_this.$$status === 'fail' && !_this.catchErrorFunc) {
            defer = _this.callBackDefer.fail;
        }
        try {
            result = callBack();
        } catch (e) {
            result = e;
            defer = _this.callBackDefer.fail;
        }
        if (result && result instanceof Promi) {
            result.then(_this.callBackDefer.success, _this.callBackDefer.fail);
            return '';
        }
        defer(result)
    },
    onReject: function(error) {
        if (this.$$status === 'pending') {
            this.$$status = 'fail';
            this.reject(error)
        }
    },
    reject: function(error) {
        let _this = this;
        _this.error = error;
        let failCallBack = _this.failCallBack;
        let _catch = _this._catch;
        if (failCallBack) {
            _this.defer(failCallBack.bind(_this, error));
        } else if (_catch) {
            _catch(error)
        } else {
            setTimeout(_ => { throw new Error('un catch promise') }, 0)
        }
    },
    then: function(success = () => {}, fail) {
        let _this = this;
        let resetFail = e => e;
        if (fail) {
            resetFail = fail;
            _this.catchErrorFunc = true;
        }
        let newPromise = new Promi(_ => {});
        _this.callBackDefer = {
            success: newPromise.onResolve.bind(newPromise),
            fail: newPromise.onReject.bind(newPromise)
        };
        _this.successCallback = success;
        _this.failCallBack = resetFail;
        return newPromise
    },
    catch: function(catchCallBack = () => {}) {
        this._catch = catchCallBack
    }
};   


// 测试代码

task()
    .then(res => {
        console.log('1:' + res)
        return '第一个then'
    })
    .then(res => {
        return new Promi(res => {
            setTimeout(_ => res('第二个then'), 3000)
        })
    }).then(res => {
        console.log(res)
   })
    .then(res => {
        return new Promi((suc, fail) => {
            setTimeout(_ => {
                fail('then失败')
           }, 400)
        })
    })
    .then(res => {
        console.log(iko)
   })
    .then(_ => {}, () => {
       return new Promi(function(res, rej) {
           setTimeout(_ => rej('promise reject'), 3000)
       })
   })
    .then()
    .then()
    .then(_ => {},
        rej => {
            console.log(rej);
            return rej + '处理完成'
        })
    .then(res => {
        console.log(res);
        // 故意出错
        console.log(ppppppp)
    })
    .then(res => {}, rej => {
        console.log(rej);
        // 再次抛错
        console.log(oooooo)
    }).catch(e => {
        console.log(e)
   })
   
```

## 11. 解析 URL 【Query URL Params】

## 12. 查找字符串中出现次数最多的字符
```js
var str = "nininihaoa";
var o = {};
for (var i = 0, length = str.length; i < length; i++) {
    var char = str.charAt(i);
    if (o[char]) {
        o[char]++; //次数加1
    } else {
        o[char] = 1; //若第一次出现，次数记为1
    }
}
console.log(o); //输出的是完整的对象，记录着每一个字符及其出现的次数
//遍历对象，找到出现次数最多的字符的次数
var max = 0;
for (var key in o) {
    if (max < o[key]) {
        max = o[key]; //max始终储存次数最大的那个
    }
}
for (var key in o) {
    if (o[key] == max) {
//console.log(key);
        console.log("最多的字符是" + key);
        console.log("出现的次数是" + max);
    }
}

```

## 13. 实现千分符(方案越多越好)
```js

function format (value) {
    if (!value) {
        return '0'
    }
    const intPartFormat = value.toString().replace(/(\d)(?=(?:\d{3})+$)/g, '$1,') // 将整数部分逢三一断
    return intPartFormat
}


function format(num){
    num=num+'';//数字转字符串
    var str="";//字符串累加
    for(var i=num.length- 1,j=1;i>=0;i--,j++){
        if(j%3==0 && i!=0){//每隔三位加逗号，过滤正好在第一个数字的情况
            str+=num[i]+",";//加千分位逗号
            continue;
        }
        str+=num[i];//倒着累加数字
    }
    return str.split('').reverse().join("");//字符串=>数组=>反转=>字符串
}

```

## 14. 手写正则【手机号码、邮箱、身份证】
```js
// 手机
 const Phone =/^(0|86|17951)?(13[0-9]|15[012356789]|166|17[3678]|18[0-9]|14[57])[0-9]{8}$/
// 邮箱
 const mailbox = /\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*/
// 身份证
const IDCard =/^(^[1-9]\d{7}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}$)|(^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])((\d{4})|\d{3}[Xx])$)$/
```

## 15. 手写下列排序方法并说明时间复杂度与空间复杂度 【冒泡排序、插入排序、快速排序、希尔排序、桶排序、选择排序、归并排序、计数排序、基数排序】

## 16. 实现一个判断回文数的函数

## 17. 将数组扁平化(不限嵌套深度 - 方法越多越好)
```js

/**
* 遍历数组arr，若arr[i]为数组则递归遍历，直至arr[i]不为数组然后与之前的结果concat。
* */


// 1. reduce
// 遍历数组每一项，若值为数组则递归遍历，否则concat。
function flatten(arr) {  
    return arr.reduce((result, item)=> {
        return result.concat(Array.isArray(item) ? flatten(item) : item);
    }, []);
}

// 2. toString & split
// 调用数组的toString方法，将数组变为字符串然后再用split分割还原为数组

function flatten(arr) {
    return arr.toString().split(',').map(function(item) {
        return Number(item);
    })
}

// 3. join & split
// 和上面的toString一样，join也可以将数组转换为字符串

function flatten(arr) {
    return arr.join(',').split(',').map(function(item) {
        return parseInt(item);
    })
}

// 4. 扩展运算符
// es6的扩展运算符能将二维数组变为一维

function flatten(arr) {
    while(arr.some(item=>Array.isArray(item))) {
        arr = [].concat(...arr);
    }
    return arr;
}
```

## 18. 打印出 1-10000 之间的所有对称数

## 19. 实现一个 add 函数, 满足如下功能

> add(1); // 1
>
> add(1)(2); // 3
>
> add(1)(2)(3); // 6
>
> add(1)(2, 3); // 6
>
> add(1, 2)(3); // 6
>
> add(1, 2, 3); // 6

## 20. 完成如下需求

> ```
> 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数
> 输入: [1, 2, 3, 4, 5, 6, 7] 和 k = 3
> 输出: [5, 6, 7, 1, 2, 3, 4]
> 解释:
> 向右旋转 1 步: [7, 1, 2, 3, 4, 5, 6]
> 向右旋转 2 步: [6, 7, 1, 2, 3, 4, 5]
> 向右旋转 3 步: [5, 6, 7, 1, 2, 3, 4]
> 
> 输入: [-1, -100, 3, 99] 和 k = 2
> 输出: [3, 99, -1, -100]
> 解释: 
> 向右旋转 1 步: [99, -1, -100, 3]
> 向右旋转 2 步: [3, 99, -1, -100] 
> ```

## 21. 给定两个数组，写一个方法来计算它们的交集

> ```
> let nums1 = [1, 2, 2, 1];
> let nums2 = [2, 2];
> //=>给定两个数组，写一个方法来计算它们的交集，输出结果 [2,2]
> ```

## 22. 两个数组和并为一个数组

> ```
> let ary1 = ['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D2'];
> let ary2 = ['A', 'B', 'C', 'D']; 
> //=>合并后的数组为：['A1', 'A2', 'A', 'B1', 'B2', 'B', 'C1', 'C2', 'C', 'D1', 'D2', 'D']
> ```

## 23. 随机生成一个长度为 10 的整数类型的数组，例如 [2, 10, 3, 4, 5, 11, 10, 11, 20]，将其排列成一个新数组，要求新数组形式如下，例如 [[2, 3, 4, 5], [10, 11], [20]]

## 24. 封装一个任意进制想换转换的函数(2 ~ 36)

## 25. N个人一起玩游戏，围成一圈，从1开始数数，数到M的人自动淘汰；最后剩下的人会取得胜利，问最后剩下的是原来的哪一位(击鼓传花)？

## 26. 求所有和为N的连续正数序列

> ```
> /*
>  * 输入一个正数N，输出所有和为N的连续正数序列
>  * 例如：输入15
>  * 结果：[[1,2,3,4,5],[4,5,6],[7,8]]
>  */
> ```

## 27. 数组中找出和为N的两个整数

> ```
> /* 
>  * 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标
>  * nums = [1,6,4,8,7];
>  * target = 9
>  * => nums[0] + nums[3] = 9
>  * => [0,3]
>  */
> ```

## 28. 实现斐波那契数列

## 29. 如果有个大文件需要上传, 你有什么方案 ?

// 实现分片上传与断点续传



